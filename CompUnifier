//desc: Gain unity receiver
import basic-util.jsfx-inc
import sample-measure.jsfx-inc
import loudness-util.jsfx-inc

in_pin: Left input
in_pin: Right input
out_pin: Left output
out_pin: Right output

slider1:50<0.1,100,0.1>Sample duration (ms)
slider2:1<0,1,1{Ready,Learning}>Learning phase mode
slider3:6<0,12,0.1>Attack
slider4:6<0,12,0.1>Sustain
slider5:-27<-54,0,0.1>Target volume
slider6:0<-24,24,0.1>Output volume
slider7:100<0,100,1>Mix
slider12:.5<.01, 1, .01>Gain difference limit

@init
ext_noinit = 1.0;
MINIMUM_VOLUME = 54;

function drawVolume(dataArray, column, r, g, b, a) local(xStart, xEnd, yStart, yEnd, dataIndex, factorColor) (
  xStart = column-1;
  xEnd = column;
  
  dataIndex = pixelMemoryIterator - (gfx_w-column);
  dataIndex < 2 ? dataIndex += gfx_w;
  
  yStart = dataArray[dataIndex-1];
  yEnd = dataArray[dataIndex];

  yStart <= 0 ? yStart = gfx_h;
  yEnd <= 0 ? yEnd = gfx_h;
  
  factorColor = .4;
  gfx_r = r * factorColor * a;
  gfx_g = g * factorColor * a;
  gfx_b = b * factorColor * a;
  gfx_line(xEnd-1, yEnd+1, xEnd-1, gfx_h);

  gfx_r = r * a;
  gfx_g = g * a;
  gfx_b = b * a;
  gfx_line(xStart, yStart, xEnd, yEnd);
  gfx_line(xStart, yStart+1, xEnd, yEnd+1);
);

function drawVisualizer() local(column) (
  column = gfx_w;
    
  loop(gfx_w,
    column > 0 ? drawVolume(gfxPixelsSample, column, 1, .5, .5, 1);
    column -= 1;
  );
);


function setGainSliderValue(ratio) (
  slider6 = round(convertRatioToDbGain(ratio), 1);
);

function getAppliedRatio() local(compensationRatio) (
    //compensate the volume difference between input and output after compression
    //compensationRatio = measureOutputIntegration.count / srate > 10 ? measureInputIntegration.average / measureOutputIntegration.average : 1;

    ((100-slider7)/100) * 1 + (slider7/100) * this.ratio * 1;
);

function releaseAttackRatio() (
    this.oldAttackRatio = (2 + this.oldAttackRatio) / 3;
);
function releaseSustainRatio() (
    this.oldSustainRatio = (2 + this.oldSustainRatio) / 3;
);
function setNewRatio(oldRatio, newRatio) local(oldRatioDb, differenceLimitDb) (
    oldRatioDb = convertRatioToDbGain(oldRatio);
    newRatioDb = convertRatioToDbGain(newRatio);
    gainDifferenceDb = oldRatioDb - newRatioDb;
    differenceLimitDb = slider12;

    abs(gainDifferenceDb) > differenceLimitDb ? (
      newRatio = 1;
      gainDifferenceDb = gainDifferenceDb * (differenceLimitDb / abs(gainDifferenceDb));
    );
    
    this.ratio = convertDbGainToRatio(oldRatioDb - gainDifferenceDb);
);

function getNextRatioInAcceleration(newRatio) local(differenceLimitDb, i) (
    newRatioDb = convertRatioToDbGain(newRatio);

    ratio0 = this.ratioMemory[0];
    ratio1 = this.ratioMemory[1];
    ratio2 = this.ratioMemory[2];
    ratio3 = this.ratioMemory[3];
    ratio4 = this.ratioMemory[4];
    ratio5 = this.ratioMemory[5];

    acceleration = acceleration(this.ratioMemory, RATIO_MEMORY_LENGTH, ratioMemoryIterator);
    previousIterator = -1;
    previousIterator == -1 ? previousIterator = RATIO_MEMORY_LENGTH - 1;
    nextRatioDbInAcceleration = this.ratioMemory[previousIterator] + acceleration;

    this.ratioMemory[ratioMemoryIterator] = newRatioDb;
    ratioMemoryIterator += 1;
    ratioMemoryIterator == RATIO_MEMORY_LENGTH ? ratioMemoryIterator = 0;

    result = convertDbGainToRatio(nextRatioDbInAcceleration);

  zzacceleration = acceleration;
    zzstandardDeviation = standardDeviation(this.ratioMemory, RATIO_MEMORY_LENGTH);
    zzdeviationByAcceleration = zzstandardDeviation / abs(acceleration);
    
    zzdeviationByAcceleration > .2 ? (
        averageRatioDb = average(this.ratioMemory, RATIO_MEMORY_LENGTH);
        result = convertDbGainToRatio(averageRatioDb);
        this.ratioAntiSaturationMode += 1;
    ) : (
        this.ratioAntiSaturationModeOff += 1;
    );


    result;
);

function computeRatio(measureVolume) local(newRatio, differenceDb) (
    volumeDb = convertRmsToDb(measureVolume);
    differenceDb = targetVolumeDb - volumeDb;
    newRatio = convertDbGainToRatio(differenceDb);
    
    volumeDb > targetVolumeDb ? (
        volumeDb < rangeUpper ? ( //limit attack
            compAttack +=1;
            newRatio = this.getNextRatioInAcceleration(newRatio);
        ) : ( //too much attack
            compAttackOutRange +=1;
            newRatio = this.ratio; //keep the higher attack ratio
        );
    );
    
    volumeDb < targetVolumeDb ? (
        volumeDb > rangeLower ? ( //add sustain
            compSustain +=1;
            newRatio = this.getNextRatioInAcceleration(newRatio);
        ) : volumeDb > gateDb ? ( //not enough sustain
            compSustainOutRange +=1;
            newRatio = this.ratio; //keep the higher sustain ratio
        ) : ( //let the volume rest in peace for silence moments
            compSilent += 1;
            newRatio = 1;
            //fuck the memory!
            this.ratioMemory = createArrayAndInit(RATIO_MEMORY_LENGTH, 0);
            this.ratioMemoryIterator = 0;
        );
    );

    //volumeDb == targetVolumeDb ? this.ratio = oldRatio; //TODO take care if reuse, because of the now undefined oldRatio variable

//    this.ratio = (2*this.ratio + newRatio) / 3;

    this.ratio = newRatio;
    setGainSliderValue(this.getAppliedRatio());
    measure.resetSample();
);

function setTargetVolume(newVolume) (
  slider5 != newVolume ? slider5 = round(newVolume, 1);
  targetVolume = convertDbLevelToRatio(newVolume);
  targetVolumeDb = newVolume;
  rangeUpper = newVolume + slider3;
  rangeLower = newVolume - slider4;
  gateDb = rangeLower - slider4;
);


//Variables initialization
learnDuration = srate;
oldMode = slider2;
measure.resetSample();
setTargetVolume(slider5);
unifier.oldAttackRatio = 1;
unifier.oldSustainRatio = 1;

RATIO_MEMORY_LENGTH = 5;
unifier.ratioMemory = createArrayAndInit(RATIO_MEMORY_LENGTH, 0);
unifier.ratioMemoryIterator = 0;

gfxPixelsSample = createArrayAndInit(gfx_w, -1);
//gfxPixelsResult = createArrayAndInit(gfx_w, -1);

zztest1 = createArray(5);
zztest1[0] = 0;
zztest1[1] = 10;
zztest1[2] = 20;
zztest1[3] = 30;
zztest1[4] = 40;
zztest1standardDeviation = standardDeviation(zztest1, 5);
zztest1acceleration = acceleration(zztest1, 5, 0);
zztest1Result = zztest1standardDeviation / zztest1acceleration;

zztest2 = createArray(5);
zztest2[0] = 0;
zztest2[1] = -20;
zztest2[2] = 10;
zztest2[3] = -20;
zztest2[4] = 10;
zztest2standardDeviation = standardDeviation(zztest2, 5);
zztest2acceleration = acceleration(zztest2, 5, 0);
zztest2Result = zztest2standardDeviation / zztest2acceleration;


zztest3 = createArray(5);
zztest3[0] = 0;
zztest3[1] = 1;
zztest3[2] = 2;
zztest3[3] = 3;
zztest3[4] = 4;
zztest3standardDeviation = standardDeviation(zztest3, 5);
zztest3acceleration = acceleration(zztest3, 5, 0);
zztest3Result = zztest3standardDeviation / zztest3acceleration;

zztest4 = createArray(5);
zztest4[0] = 0;
zztest4[1] = -2;
zztest4[2] = 1;
zztest4[3] = -2;
zztest4[4] = 1;
zztest4standardDeviation = standardDeviation(zztest4, 5);
zztest4acceleration = acceleration(zztest4, 5, 0);
zztest4Result = zztest4standardDeviation / zztest4acceleration;


@slider
learnDuration = slider1 / 1000 * srate;
setTargetVolume(slider5);

slider2 == oldMode && slider2 == 0 ? ( //parameters changes, output measure has to be restarted
    slider2 = 1;
    measureOutputIntegration.resetSample();
);

 
@block
measure.count >= learnDuration ? (
  unifier.computeRatio(measure.average);
);


@sample
sample.getSample(spl0, spl1);

measure.learnNewLevel(sample.getAbsoluteVolume());
slider2 == 1 ? (
    oldMode == 0 ? (
        measureInputIntegration.count / srate < 10 ? measureInputIntegration.resetSample();
        measureOutputIntegration.resetSample();
        oldMode=1;
    );

    measureOutputIntegration.count / srate >= 10 ? ( //TODO add more condition on input/output integration stabilization
        slider2 = 0;
        differenceToCompensate = convertRatioToDbGain(measureInputIntegration.average / measureOutputIntegration.average);
    ) : (
        setTargetVolume(convertRmsToDb(measureInputIntegration.average));
        measureInputIntegration.learnNewLevel(sample.getAbsoluteVolume());
        measureInputIntegration.count / srate >= 10 ? measureOutputIntegration.learnNewLevel(result.getAbsoluteVolume()); //learn if input is ready
    );
);
oldMode = slider2;


result.getSample(unifier.getAppliedRatio() * sample.left, unifier.getAppliedRatio() * sample.right);
resultDb = convertRmsToDb(result.getAbsoluteVolume());

timeCounter == srate/100 ? (
  gfxPixelsSample[pixelMemoryIterator] = pixelSampleMemory / timeCounter;
  //gfxPixelsResult[pixelMemoryIterator] = pixelResultMemory / timeCounter;
  pixelSampleMemory = 0;
  pixelResultMemory = 0;
  pixelMemoryIterator += 1;
  pixelMemoryIterator == gfx_w ? pixelMemoryIterator = 1;
  timeCounter = 0;
);

pixelSampleMemory += spl0 != 0 ? -volumeDb / MINIMUM_VOLUME * gfx_h : -1;
//pixelResultMemory += spl0 != 0 ? -resultDb / MINIMUM_VOLUME * gfx_h : -1;
timeCounter += 1;


spl0 = result.left;
spl1 = result.right;



@gfx 300 600
heightTarget = -targetVolumeDb / MINIMUM_VOLUME * gfx_h;
heightUpper = -(rangeUpper) / MINIMUM_VOLUME * gfx_h;
heightLower = -(rangeLower) / MINIMUM_VOLUME * gfx_h;
heightGate = -(gateDb) / MINIMUM_VOLUME * gfx_h;

backgroundColor = .12;
gfx_r=backgroundColor -.05;
gfx_g=backgroundColor -.00;
gfx_b=backgroundColor +.05;

gfx_rect(0, 0, gfx_w, gfx_h);

drawVisualizer();

//range limits
gfx_r=.6;
gfx_g=.6;
gfx_b=0;
gfx_line(0, heightUpper, gfx_w, heightUpper);
gfx_line(0, heightLower, gfx_w, heightLower);

gfx_x=gfx_y=0;
gfx_blurto(gfx_w, gfx_h);

//gate
gfx_r=.6;
gfx_g=0;
gfx_b=0;
gfx_line(0, heightGate, gfx_w, heightGate);

//target
gfx_r=0;
gfx_g=.9;
gfx_b=0;
gfx_line(0, heightTarget, gfx_w, heightTarget);
