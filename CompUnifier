//desc: Gain unity receiver
import basic-util.jsfx-inc
import sample-measure.jsfx-inc
import loudness-util.jsfx-inc

in_pin: Left input
in_pin: Right input
out_pin: Left output
out_pin: Right output

slider1:50<0.1,100,0.1>Sample duration (ms)
slider2:1<0,1,1{Ready,Learning}>Learning phase mode
slider3:6<0,12,0.1>Attack
slider4:6<0,12,0.1>Sustain
slider5:-27<-54,0,0.1>Target volume
slider6:0<-24,24,0.1>Output volume
slider7:100<0,100,1>Mix
slider12:.5<.01, 1, .01>Gain difference limit


@init
ext_noinit = 1.0;

function drawVolume(data, dataBefore, column, r, g, b, a, fillGraphAndBigLine) local(xStart, xEnd, yStart, yEnd, factorColor) (
  xStart = column-1;
  xEnd = column;

  yStart = dataBefore;
  yEnd = data;

  yStart <= 0 ? yStart = gfx_h;
  yEnd <= 0 ? yEnd = gfx_h;

  fillGraphAndBigLine == 1 ? (
      factorColor = .4;
      gfx_r = r * factorColor * a;
      gfx_g = g * factorColor * a;
      gfx_b = b * factorColor * a;
      gfx_line(xEnd-1, yEnd+1, xEnd-1, gfx_h);
  );

  gfx_r = r * a;
  gfx_g = g * a;
  gfx_b = b * a;
  gfx_line(xStart, yStart, xEnd, yEnd);
  fillGraphAndBigLine ? gfx_line(xStart, yStart+1, xEnd, yEnd+1);
);

function drawVolumeDifference(inputVolume, outputVolume, inputVolumeBefore, outputVolumeBefore, column, r, g, b, a) local(y) (
    gfx_r = r * a;
    gfx_g = g * a;
    gfx_b = b * a;
    gfx_line(column, inputVolume, column, outputVolume);
    gfx_line(column-1, inputVolumeBefore, column, outputVolumeBefore-1);
);

function drawVisualizer() local(column, dataIndex) (
  column = gfx_w;
    
  loop(gfx_w,
    dataIndex = this.memoryIterator - (gfx_w-1-column);
    dataIndex < 1 ? dataIndex += VISUALIZER_MEMORY_LENGTH - 1;

    column >= 0 ? (
        //visualizer.drawVolumeDifference(this.inputMemory[dataIndex], this.outputMemory[dataIndex-1], this.inputMemory[dataIndex], this.outputMemory[dataIndex-1], column, 1, 1, 1, .35);
        visualizer.drawVolume(this.inputMemory[dataIndex], this.inputMemory[dataIndex-1], column, 1, .5, .5, 1, 0);
        //visualizer.drawVolume(this.outputMemory[dataIndex], this.outputMemory[dataIndex-1], column, .5, 1, 1, 1, 0);
        visualizer.drawVolume(this.ratioMemory[dataIndex], this.ratioMemory[dataIndex-1], column, 0, .5, 1, 1, 0);
    );
    column -= 1;
  );
);

function addSignalLevels(targetVolumeDb, inputVolume, currentRatio) local(inputVolumeDb) (
    inputVolumeDb = convertRmsToDb(inputVolume);
    currentRatioDb = convertRatioToDbGain(currentRatio);

    this.inputMemory[this.memoryIterator] = (-inputVolumeDb / MINIMUM_VOLUME * gfx_h);
    this.ratioMemory[this.memoryIterator] = (-(targetVolumeDb + currentRatioDb) / MINIMUM_VOLUME * gfx_h);
    this.outputMemory[this.memoryIterator] = (-(inputVolumeDb + currentRatioDb) / MINIMUM_VOLUME * gfx_h);

    this.memoryIterator += 1;
    this.memoryIterator == VISUALIZER_MEMORY_LENGTH ? this.memoryIterator = 0;
);



function setGainSliderValue(ratio) (
  slider6 = round(convertRatioToDbGain(ratio), 1);
);

function setTargetVolume(newVolumeDb) (
  slider5 != newVolumeDb ? slider5 = round(newVolumeDb, 1);
  targetVolume = convertDbLevelToRatio(newVolumeDb);
  targetVolumeDb = newVolumeDb;
  rangeUpperDb = newVolumeDb + slider3;
  rangeLowerDb = newVolumeDb - slider4;
  gateDb = rangeLowerDb - slider4;
);



function autoLearnInputOutput() (
    slider2 == 1 ? (
        oldMode == 0 ? (
            measureInputIntegration.count / srate < 10 ? measureInputIntegration.resetSample();
            measureOutputIntegration.resetSample();
            oldMode=1;
        );

        measureOutputIntegration.count / srate >= 10 ? ( //TODO add more condition on input/output integration stabilization
            slider2 = 0;
            differenceToCompensate = convertRatioToDbGain(measureInputIntegration.average / measureOutputIntegration.average);
        ) : (
            setTargetVolume(convertRmsToDb(measureInputIntegration.average));
            measureInputIntegration.learnNewLevel(sample.getAbsoluteVolume());
            measureInputIntegration.count / srate >= 10 ? measureOutputIntegration.learnNewLevel(result.getAbsoluteVolume()); //learn if input is ready
        );
    );
    oldMode = slider2;
);



function getAppliedRatio() local(compensationRatio) (
    //compensate the volume difference between input and output after compression
    //compensationRatio = measureOutputIntegration.count / srate > 10 ? measureInputIntegration.average / measureOutputIntegration.average : 1;

    ((100-slider7)/100) * 1 + (slider7/100) * this.ratio * 1;
);

function computeRatio(measureVolume) local(newRatio, differenceDb, newRatio) (
    volumeDb = convertRmsToDb(measureVolume);
    differenceDb = targetVolumeDb - volumeDb;
    newRatio = convertDbGainToRatio(differenceDb);
    
    volumeDb > targetVolumeDb ? (
        volumeDb < rangeUpperDb ? ( //limit attack
            compAttack +=1;
        ) : ( //too much attack
            compAttackOutRange +=1;
        );
    );
    
    volumeDb < targetVolumeDb ? (
        volumeDb > rangeLowerDb ? ( //add sustain
            compSustain +=1;
        ) : volumeDb > gateDb ? ( //not enough sustain
            compSustainOutRange +=1;
        ) : ( //let the volume rest in peace for silence moments
            compSilent += 1;
        );
    );

    //this.ratio = (2*this.ratio + newRatio) / 3;
    this.ratio = newRatio;
    setGainSliderValue(this.getAppliedRatio());
);



//Variables initialization
MINIMUM_VOLUME = 54;
learnDuration = srate;
oldMode = slider2;
measure.resetSample();
setTargetVolume(slider5);
unifier.oldAttackRatio = 1;
unifier.oldSustainRatio = 1;

RATIO_MEMORY_LENGTH = 5;
unifier.ratioMemory = createArrayAndInit(RATIO_MEMORY_LENGTH, 0);
unifier.ratioMemoryIterator = 0;


VISUALIZER_MEMORY_LENGTH = 2000;
visualizer.inputMemory = createArrayAndInit(VISUALIZER_MEMORY_LENGTH, -1);
visualizer.ratioMemory = createArrayAndInit(VISUALIZER_MEMORY_LENGTH, -1);
visualizer.outputMemory = createArrayAndInit(VISUALIZER_MEMORY_LENGTH, -1);
visualizer.memoryIterator = 0;
visualizer.signalCounter = 0; //for data/frame synchronization


@slider
learnDuration = slider1 / 1000 * srate;
setTargetVolume(slider5);

/*
slider2 == oldMode && slider2 == 0 ? ( //parameters changes, output measure has to be restarted
    slider2 = 1;
    measureOutputIntegration.resetSample();
);*/


 
@block
measureAverage = measure.average;

measure.count >= learnDuration ? (
    unifier.computeRatio(measureAverage);
    measure.resetSample();
);

signalDetected == 0 ? (
    unifier.ratio = 1;
    setGainSliderValue(this.getAppliedRatio());
);

visualizer.signalCounter >= srate/100 ? (
    visualizer.addSignalLevels(targetVolumeDb, signalDetected == 1 ? measureAverage : -1, unifier.getAppliedRatio());
    visualizer.signalCounter = 0;
);




@sample
sample.getSample(spl0, spl1);

signalDetected = measure.learnNewLevel(sample.getAbsoluteVolume());
visualizer.signalCounter += 1;
autoLearnInputOutput();


result.getSample(unifier.getAppliedRatio() * sample.left, unifier.getAppliedRatio() * sample.right);
resultDb = convertRmsToDb(result.getAbsoluteVolume());




spl0 = result.left;
spl1 = result.right;











@gfx 300 600
heightTarget = -targetVolumeDb / MINIMUM_VOLUME * gfx_h;
heightUpper = -(rangeUpperDb) / MINIMUM_VOLUME * gfx_h;
heightLower = -(rangeLowerDb) / MINIMUM_VOLUME * gfx_h;
heightGate = -(gateDb) / MINIMUM_VOLUME * gfx_h;

//background
backgroundColor = .12;
gfx_r=backgroundColor -.05;
gfx_g=backgroundColor -.00;
gfx_b=backgroundColor +.05;
gfx_rect(0, 0, gfx_w, gfx_h);

visualizer.drawVisualizer();

//gfx_x=gfx_y=0;
//gfx_blurto(gfx_w, gfx_h);


//range limits
gfx_r=.6;
gfx_g=.6;
gfx_b=0;
gfx_line(0, heightUpper, gfx_w, heightUpper);
gfx_line(0, heightLower, gfx_w, heightLower);

//gate
gfx_r=.6;
gfx_g=0;
gfx_b=0;
gfx_line(0, heightGate, gfx_w, heightGate);

//target
gfx_r=0;
gfx_g=.9;
gfx_b=0;
gfx_line(0, heightTarget, gfx_w, heightTarget);
